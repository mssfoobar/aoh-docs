"use strict";(self.webpackChunkaoh_documentation=self.webpackChunkaoh_documentation||[]).push([[6490],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=s(n),f=i,m=p["".concat(c,".").concat(f)]||p[f]||d[f]||o;return n?r.createElement(m,a(a({ref:t},u),{},{components:n})):r.createElement(m,a({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=f;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[p]="string"==typeof e?e:i,a[1]=l;for(var s=2;s<o;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},12679:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(87462),i=(n(67294),n(3905));const o={sidebar_position:2},a="\ud83d\udcbb Development",l={unversionedId:"wfe/guides/Workflow Worker/development",id:"wfe/guides/Workflow Worker/development",title:"\ud83d\udcbb Development",description:"Activity",source:"@site/docs/90_wfe/guides/Workflow Worker/development.md",sourceDirName:"90_wfe/guides/Workflow Worker",slug:"/wfe/guides/Workflow Worker/development",permalink:"/aoh-docs/docs/wfe/guides/Workflow Worker/development",draft:!1,editUrl:"https://github.com/mssfoobar/aoh-docs/tree/main/docs/90_wfe/guides/Workflow Worker/development.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"wfe",previous:{title:"\ud83d\udcbb Development",permalink:"/aoh-docs/docs/wfe/guides/Workflow Engine/development"},next:{title:"Form Designer",permalink:"/aoh-docs/docs/wfe/Designer Suite/form_designer"}},c={},s=[{value:"Activity",id:"activity",level:2},{value:"Activity Function Definition",id:"activity-function-definition",level:3},{value:"Dynamic Activity Registration",id:"dynamic-activity-registration",level:3},{value:"Activity Heartbeat",id:"activity-heartbeat",level:3}],u={toc:s},p="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"-development"},"\ud83d\udcbb Development"),(0,i.kt)("h2",{id:"activity"},"Activity"),(0,i.kt)("p",null,"An Activity is a normal function or method that executes a single, well-defined action (either short or long-running), such as calling another service, transcoding a media file, or sending an email message. Activity code should be deterministic."),(0,i.kt)("h3",{id:"activity-function-definition"},"Activity Function Definition"),(0,i.kt)("p",null,"Let's define a simple activity which has input and output as string data type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'type Activities struct{}\n\nfunc (a *Activities) SimpleActivity(ctx context.Context, input []interface{}) (string, error) {\n  str, ok := input[0].(string)\n    if !ok {\n        return nil, errors.New("invalid input")\n    }\n    return "Result_" + str, nil\n}\n')),(0,i.kt)("p",null,"The first parameter of an activity definition is a context.",(0,i.kt)("br",{parentName:"p"}),"\n","Context is used by Temporal to pass around Workflow Execution Context."),(0,i.kt)("p",null,"The second parameter is an array of interface{}.\nWe use an array of interface{} to support the Workflow Engine to interpret as many parameters as defined by the Activity Developer.",(0,i.kt)("br",{parentName:"p"}),"\n","It is important to always typecast the input parameter and return error if there is to avoid runtime errors."),(0,i.kt)("p",null,"And then we return the result as string."),(0,i.kt)("h3",{id:"dynamic-activity-registration"},"Dynamic Activity Registration"),(0,i.kt)("p",null,"If you notice in earlier example, we have declared ",(0,i.kt)("inlineCode",{parentName:"p"},"Activites")," struct type and defined the function with receiver as ",(0,i.kt)("inlineCode",{parentName:"p"},"Actvities"),".",(0,i.kt)("br",{parentName:"p"}),"\n","Reason is we want to register the activity dynamically which allow us to add new activities in Workflow Worker without having to rebuild the Workflow Engine.\nOtherwise, Workflow Engine service will need to statically register the activities defined in Workflow Worker service."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n// ...\n    yourWorker := worker.New(temporalClient, "your-custom-task-queue-name", worker.Options{})\n\n    yourWorker.RegisterActivityWithOptions(&yourapp.Activities{})\n\n    err = yourWorker.Run(worker.InterruptCh())\n// ...\n}\n')),(0,i.kt)("h3",{id:"activity-heartbeat"},"Activity Heartbeat"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"To allow cancellation of the activity, it must heartbeat periodically")),(0,i.kt)("p",null,"If the activity is a long-running process (eg Event listener), it must heartbeat to allow the activity cancellation."),(0,i.kt)("p",null,"Below is an example HttpCall activity. Note that before and after executing long-running processes, it will heartbeat and catch cancellation from the workflow."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// HttpCall take in \'method\', \'endpoint\' and \'payload\' as input\n// Successful execution return http response\nfunc (a *Activities) HttpCall(ctx context.Context, input []interface{}) (interface{}, error) {\n    logger := activity.GetLogger(ctx)\n\n    method, ok := input[0].(string)\n    if !ok {\n        return nil, errors.New("invalid input")\n    }\n    endpoint, ok := input[1].(string)\n    if !ok {\n        return nil, errors.New("invalid input")\n    }\n    payload, ok := input[2].(string)\n    if !ok {\n        return nil, errors.New("invalid input")\n    }\n\n    b := []byte(payload)\n\n    client := &http.Client{}\n\n    req, err := http.NewRequest(method, endpoint, bytes.NewReader(b))\n    if err != nil {\n        return nil, err\n    }\n\n    // heartbeat report before long-running process\n    activity.RecordHeartbeat(ctx, "status-report-to-workflow")\n    // catch cancellation from workflow by checking ctx.Done\n    select {\n    case <-ctx.Done():\n    return nil, ctx.Err()\n    default:\n    }\n    \n    res, err := client.Do(req)\n    if err != nil {\n        return nil, err\n    }\n\n    // heartbeat after long-running process\n    activity.RecordHeartbeat(ctx, "status-report-to-workflow")\n    // catch cancellation from workflow by checking ctx.Done\n    select {\n    case <-ctx.Done():\n        return nil, ctx.Err()\n    default:\n    }\n\n    body, err := io.ReadAll(res.Body)\n    if err != nil {\n        return nil, err\n    }\n    defer func() {\n        if err := res.Body.Close(); err != nil {\n            logger.Error(err.Error())\n        }\n    }()\n\n    var result interface{}\n    if err := json.Unmarshal(body, &result); err != nil {\n        return nil, err\n    }\n\n    // catch cancellation from workflow by checking ctx.Done\n    select {\n    case <-ctx.Done():\n        return nil, ctx.Err()\n    default:\n    }\n\n    return result, nil\n}\n')))}d.isMDXComponent=!0}}]);