"use strict";(self.webpackChunkaoh_documentation=self.webpackChunkaoh_documentation||[]).push([[6571],{39520:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=n(74848),o=n(28453);const s={sidebar_position:1},d="Dashboarding",a={id:"web/api/dashboard",title:"Dashboarding",description:"AGIL Ops Hub deals with dashboarding with a custom widget system using GridStack.js. Widgets",source:"@site/docs/40_web/20_api/10_dashboard.md",sourceDirName:"40_web/20_api",slug:"/web/api/dashboard",permalink:"/aoh-docs/docs/web/api/dashboard",draft:!1,unlisted:!1,editUrl:"https://github.com/mssfoobar/aoh-docs/tree/main/docs/40_web/20_api/10_dashboard.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"web",previous:{title:"API",permalink:"/aoh-docs/docs/category/api"},next:{title:"Theming System",permalink:"/aoh-docs/docs/web/api/theming"}},r={},l=[{value:"Fullscreen Mode",id:"fullscreen-mode",level:3},{value:"Resizability Considerations",id:"resizability-considerations",level:3},{value:"Extending your components to work with the widget system",id:"extending-your-components-to-work-with-the-widget-system",level:2},{value:"Providing important widget properties",id:"providing-important-widget-properties",level:2},{value:"Data Sources",id:"data-sources",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"dashboarding",children:"Dashboarding"}),"\n",(0,i.jsxs)(t.p,{children:["AGIL Ops Hub deals with dashboarding with a custom widget system using ",(0,i.jsx)(t.a,{href:"https://gridstackjs.com/",children:"GridStack.js"}),". Widgets\ncan be moved, resized, added, and removed in a dynamic grid."]}),"\n",(0,i.jsx)(t.h3,{id:"fullscreen-mode",children:"Fullscreen Mode"}),"\n",(0,i.jsxs)(t.p,{children:["A notable use case of displaying dashboards is to allow it to be projected onto a 'video wall'. This requires hiding\nthe navigation and status bars so that only the dashboard is being displayed - this can be done by clicking the\nfullscreen icon. In fullscreen mode, the only way to exit is to press the ",(0,i.jsx)(t.code,{children:"ESC"})," key."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Fullscreen Mode",src:n(52318).A+"",width:"1049",height:"623"})}),"\n",(0,i.jsx)(t.h3,{id:"resizability-considerations",children:"Resizability Considerations"}),"\n",(0,i.jsx)(t.p,{children:"To support widgets being resizable whilst maintaining an adequate user experience, widgets need to be designed to be\nresponsive. Developers can specify what the default width and height widgets should have, and what range of sizes\nthey are constrained to (including being unconstrained). The dashboard will also grow (vertically) to accomodate to\nthe size of widgets that have been added (disabling vertical growth introduces other user experience problems, such as\ndisallowing the addition of widgets that do not fit into a fix-sized dashboard). The horizontal size of the dashboard is\nfixed (default 24 columns)."}),"\n",(0,i.jsx)(t.h2,{id:"extending-your-components-to-work-with-the-widget-system",children:"Extending your components to work with the widget system"}),"\n",(0,i.jsxs)(t.p,{children:["To enable your component to be registered to the widget system, create a new folder in\n",(0,i.jsx)(t.code,{children:"/src/lib/core/modules/dashboard/components/widgets"}),". Give the folder a name to describe your widget; e.g. ",(0,i.jsx)(t.code,{children:"Indicator"}),".\nFor a ",(0,i.jsx)(t.code,{children:".svelte"})," file to be regitered into the widget systen, you must create a folder called ",(0,i.jsx)(t.code,{children:"WidgetConfig"})," adjacent to\nit, and create an ",(0,i.jsx)(t.code,{children:"index.svelte"})," file in it."]}),"\n",(0,i.jsx)(t.p,{children:"The following 4 highlighted lines are the new files/folders you should have."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",metastring:"{8-11}",children:"src\n\u251c\u2500\u2500 lib\n\u2502   \u251c\u2500\u2500 core\n\u2502   \u2502   \u251c\u2500\u2500 modules\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 dashboard\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 components\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 widgets\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Indicator\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 index.svelte\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 WidgetConfig\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502       \u2514\u2500\u2500 index.svelte\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 ...\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"Indicator/index.svelte"})," is the actual Svelte component definition of your widget (how it should look and behave), and\n",(0,i.jsx)(t.code,{children:"WidgetConfig/index.svelte"}),"is the Svelte component that can be used to configure your widget."]}),"\n",(0,i.jsxs)(t.p,{children:["Your component will now appear in the ",(0,i.jsx)(t.code,{children:"WidgetList"})," component, which is instantiated in the ",(0,i.jsx)(t.code,{children:"WidgetView"})," component,\nwhich is in turn instantiated in the ",(0,i.jsx)(t.code,{children:"dashboard"})," page; it can now be added or removed from the widget dashboard."]}),"\n",(0,i.jsxs)(t.p,{children:["Your ",(0,i.jsx)(t.code,{children:"WidgetConfig"})," component is meant to provide configuration controls for your new 'widgetized' component, here is\nan example configuration widget that just accepts a text input. The text input's value is then bound to the desired\nconfig property (in this case ",(0,i.jsx)(t.code,{children:"threshold"}),"), and that value gets passed to your widget in the ",(0,i.jsx)(t.code,{children:"dashboard"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["You ",(0,i.jsx)(t.em,{children:"must"})," declare the 'config' prop and use it to pass values to your main widget."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:"title=MyFavouriteComponent/WidgetConfig/index.svelte",children:'<script lang="ts">\n  export let config = { color: "red" }; //default\n<\/script>\n\n<div>Config: </div>\n<input bind:value={ config.color } />\n\n'})}),"\n",(0,i.jsx)(t.p,{children:"Inside your main component, to read the config data, you export the same 'config' prop - then read that prop and use\nthe values you want accordingly. When your components are rendered dynamically, the 'config' prop is passed from the\nconfiguration component to the main component."}),"\n",(0,i.jsx)(t.p,{children:"This config will then be persisted and read to load the widget-specific configuration."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:"title=MyFavouriteComponent/index.svelte",children:'<script>\n  export let config = { color: "red" }; // 2-way bound default\n<\/script>\n\n<div style="border: 1px solid; padding: 1rem; ;{ config ? `color: ${config.color}` : \'\'}">\n  Foo Bar\n</div>\n\n'})}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsxs)(t.p,{children:["If you want to know more, you can view this simple example on StackBlitz to understand how the components are\ndynamically rendered and the config prop is passed in: ",(0,i.jsx)(t.a,{href:"https://stackblitz.com/edit/dynamic-rendering-with-config",children:"https://stackblitz.com/edit/dynamic-rendering-with-config"})]}),(0,i.jsx)(t.p,{children:"The StackBlitz example is a heavily simplified version without GridStack and saving incorporated."})]}),"\n",(0,i.jsx)(t.h2,{id:"providing-important-widget-properties",children:"Providing important widget properties"}),"\n",(0,i.jsx)(t.p,{children:"Upon adding your widget to the widget view, it will get initialized with a default size - to ensure your widget looks\nnice, you need to specify what that size should be, you do this by exporting some constants that will be bound to your\nwidget when it's initialized in the grid."}),"\n",(0,i.jsx)(t.p,{children:"You will also need to export a title, and Font Awesome icon that will be used to represent your widget for during\nselection."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:"title=MyFavouriteComponent/index.svelte {5-8}",children:"<script lang=\"ts\">\n  import { faToilet } from '@fortawesome/pro-duotone-svg-icons';\n\n  export let config = { color: \"red\" }; // 2-way bound default\n  export const widgetTitle = 'My Favourite Widget';\n  export const widgetIcon = faToilet;\n  export const widgetWidth = 2;\n  export const widgetHeight = 2;\n  export const widgetMinWidth = 4;\n  export const widgetMinHeight = 4;\n  export const widgetMaxWidth = 8;\n  export const widgetMaxHeight = 8;\n  export const widgetCategory = 'Demo Widgets';\n  export const widgetLimit = Number.POSITIVE_INFINITY;\n  export const widgetEnabled = true;\n<\/script>\n\n<div style=\"border: 1px solid; padding: 1rem; ;{ config ? `color: ${config.color}` : ''}\">\n  Foo Bar\n</div>\n\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"widgetWidth"})," and ",(0,i.jsx)(t.code,{children:"widgetHeight"})," determine how your widget will be initially rendered before users drag the resize\nhandle and change its size."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"widgetMinWidth"}),", ",(0,i.jsx)(t.code,{children:"widgetMinHeight"}),", ",(0,i.jsx)(t.code,{children:"widgetMaxWidth"}),", and ",(0,i.jsx)(t.code,{children:"widgetMaxHeight"})," are used\nto limit how much smaller or larger the widget can be resized in terms of cells. Specifying these values are to\nrestrict the bounds of the widget so people won't be able to resize the widget beyond its intended size."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"widgetCategory"})," refers to which accordion category in the widget list that this new widget will appear in; this is\nfor filtering and categorization purposes."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"widgetLimit"})," determines how many instances of this same widget is allowed in a single dashboard at any one time."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"widgetEnabled"})," this boolean can be set to false if you do not wish for this widget to be available to add into the\ndashboard - you can use this flag to disable widgets your widgets that are no longer in use without having to delete\nthem"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"A template widget that provides a good springboard for creating new widgets exists in the widget folder, and can be\ncopied and modified accordingly. It also has an example on how to subscribe to changes in data in your widget, and how\nto use configurable data sources; which will be elaborated on in the next section."}),"\n",(0,i.jsx)(t.h2,{id:"data-sources",children:"Data Sources"}),"\n",(0,i.jsx)(t.p,{children:"For many widgets in the dashboard, it is desirable for them to track certain values in the system - for example, how\nmany incidents are currently open. Widgets can have a hard-coded GraphQL subscription to certain data sources... or,\nwith the power of GraphQL introspection, can have these queries be dynamically configured."}),"\n",(0,i.jsxs)(t.p,{children:["Within the core library (",(0,i.jsx)(t.code,{children:"src/lib/core/core.ts"}),"), a store called ",(0,i.jsx)(t.code,{children:"dataSource"})," is exported. This data source store is\npopulatd when the app-wide layout is loaded, allowing it to be accessible by all components. This data source is\nessentially just a simplified GraphQL introspection query. You can use this to limit (or have no limit)\nwhat data sources a widget an be configured to use; for example, in the template widget, it is limiting selectable\ndata sources to any aggregate queries with ",(0,i.jsx)(t.code,{children:"sum"})," in it, and whose column/field is named 'number'."]}),"\n",(0,i.jsxs)(t.p,{children:["You can see how this is done in the template widget's WidgetConfig below; the schema/introspection query is iterated\nthrough to look for any field that follows the expected format (named ",(0,i.jsx)(t.code,{children:"number"})," and of type ",(0,i.jsx)(t.code,{children:"numeric"}),"), and limited to\naggregate sums - limiting the selection this way makes it easier for users to configure their widgets, but allowing\nfull access to all data sources and providing a universal selector and mapper is also a viable solution (albeit this\nmight provide a paralyzingly large clutter of options to the user)."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",metastring:"title=Template/WidgetConfig/index.svelte {4,14}",children:'// Irrelevant code above ...\n\n// Limit to only fields that are named \'number\'\nexport const expectedFormat = [{ name: "number", type: "numeric" }];\n\n// Irrelevant code between ...\n\n// List of data source names (valid GraphQL query roots)\nconst validQueries: Array<DropdownItem> = [];\n\n// Look for aggregate > sum queries with expected format\n// aggregate > sum follows Hasura\'s aggregate sum schema\n$dataSource.__schema?.types?.forEach((query) => {\n    let isQueryValid = expectedFormat.every((format) => {\n        return query?.fields?.some((field) => {\n            if (field?.name !== "aggregate") {\n                return false;\n            }\n\n            let aggregateFields = field?.type?.fields;\n\n            return aggregateFields.some((aField) => {\n                if (aField?.name !== "sum") {\n                    return false;\n                }\n\n                let sumFields = aField?.type?.fields;\n\n                return sumFields.some(\n                    (sField) =>\n                        sField?.name === format.name &&\n                        sField?.type?.name === format.type\n                );\n            });\n        });\n    });\n\n    if (isQueryValid) {\n        validQueries.push({ label: query.name, value: query.name });\n    }\n});\n\n// Irrelevant code below ...\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},52318:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/fullscreen-bbe0df661853664aa95ef4272b926205.png"},28453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>a});var i=n(96540);const o={},s=i.createContext(o);function d(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);