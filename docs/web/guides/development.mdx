---
sidebar_position: 1
---

# Development ðŸ’»

The scope of this document is not to be a tutorial on [Svelte](https://svelte.dev/tutorial/basics) and
[Svelte Kit](https://kit.svelte.dev/docs/introduction), you should visit their official documentation to learn more
about them. This is meant to be a quick reference to help you can create components using our stack; how our folders are
structured, how `state` is managed, how we approach unit and end-to-end testing, etc.

## Creating A Simple Svelte Component

Our components rest inside the `src/lib/components` folder. Each component rests in a separate folder with the following
files:

-   `index.svelte`: The Svelte file for the component
-   `index.d.ts`: Ambient declaration file to support the component
-   `test.svelte`: An instantiation of the component, used to test the component, as well as provide examples on how to
    use it
-   `comp.test.ts`: The _Playwright_ test for the component - the project is configured to visit and perform actions on
    the _test.svelte_ file via the `/tests` route.

### [index.svelte](https://svelte.dev/repl/286607b464814418b643d47400463644?version=3.49.0)

View the code on [Svelte REPL](https://svelte.dev/repl/286607b464814418b643d47400463644?version=3.49.0)

The following is a simple Svelte component demonstrating data binding, reactivity, and iteratively rendering based on
data.

```tsx title="index.svelte"
<script>
	let exampleObjects = [];
	let currentText = "Hello new developer!";

	let totalCount = 1;

	function addObject() {
		exampleObjects.push({text: currentText, count: totalCount});
		exampleObjects = exampleObjects; // reactivity is based on assignments, assign it to itself to force reactivity
		totalCount++;
	}
</script>

<input type="text" bind:value={currentText}>
<button on:click={addObject}>
	ADD OBJECT
</button>
<div>
	{#each exampleObjects as xo }
		<div>
			{xo.count}. {xo.text}
		</div>
	{/each}
</div>
```

Though `JavaScript` is loved for it's speed of development and flexibility, the great freedom provided by it also makes
maintaining large projects a nightmare. `TypeScript` is a must - it allows yourself and other developers to understand
the shape of the objects being passed around. To have your types available throughout the project, we use an ambient
typescript declaration file:

### index.d.ts

Here's an example declaration for the component we wrote:

```ts title="index.d.ts"
declare interface ExampleObject {
    text: string;
    count: number;
}
```

And here is the TypeScript version of that componet (the `index.svelte`) shown earlier.

```tsx title="index.svelte"
<script lang="ts">
	let exampleObjects: Array<ExampleObject> = [];
	let currentText = "Hello new developer!";

	let totalCount = 1;

	function addObject() {
		exampleObjects.push({text: currentText, count: totalCount});
		exampleObjects = exampleObjects;
		totalCount++;
	}
</script>

<input type="text" bind:value={currentText}>
<button on:click={addObject}>
	ADD OBJECT
</button>
<div>
	{#each exampleObjects as xo }
		<div>
			{xo.count}. {xo.text}
		</div>
	{/each}
</div>
```

With the ambient declaration file, we can use the `ExampleObject` throughout our project, enabling great features like
type checking and IntelliSense.

### [test.svelte](https://svelte.dev/repl/54ac8421e91e4506aa515ce92290fb9e?version=3.49.0)

Every component should have examples on how to use them, and tests to ensure they are running correct. We provide these
by having a `test.svelte` file next to our `index.svelte` file.

Example usage of `index.svelte`:

```tsx title="test.svelte"
<script>
	import DeveloperGreeter from './index.svelte';
</script>

<div>
	<h1>
		Look at this thing I made:
	</h1>
	<DeveloperGreeter />
</div>
```

### comp.test.ts

For unit-testing components, we have the component folder structure mirrored in the `/tests` route, and we dynamically
render the components based on the route. We then have `Playwright` visit the component pages to perform tests on them.

Here is a sample of what the `comp.test.ts` file might look like for the component we wrote above:

```tsx title="comp.test.ts"
import { test } from '@playwright/test';

test('click buttons', async ({ page }) => {
    // Go to http://localhost:4173/tests/components/basic/Button
    await page.goto('http://localhost:4173/tests/components/DeveloperGreeter');
    await page.locator("text='ADD OBJECT'").click();
    await page.locator("text='1. Hello new developer!'").toBeVisible();
});
```

In the future, we might switch to Playwright's [`components`](https://playwright.dev/docs/test-components) feature.
However, it is still currently experiemental.

## Styling and Theming

[Tailwind CSS](https://tailwindcss.com/) is a responsive, highly extensible, utility-first CSS framework. It has a
design system built-in, like Bootstrap, but unlike Bootstrap, it is much more flexible and meant to be used a little
bit like in-lining your CSS. Read their [core concepts](https://tailwindcss.com/docs/utility-first) to learn more
about the rationale behind Tailwind.

For theming, we use [Tailwind's theme configuration system](https://tailwindcss.com/docs/theme) to create our own
themes. In the `tailwind.config.cjs` file, you can see how we have it extended.

The colors are named and assigned to a list of CSS variables that are assigned to the root element (`html`) - you can
see this in the `app.html` file:

```html title="app.html"
<html lang="en" class="theme-1 bg-background"></html>
```

The default theme is called `theme-1` and `bg-background` is the background color (specified with `bg-`) using the
`background` key that we've assigned in the `tailwind.config.cjs` file. That `background` is given the CSS variable
`--background-color: 255 255 255`, which is defined in `themes.css`.

```css title="themes.css"
--background-color: 255 255 255;
```

Changing this variable changes the color for anything using `background` and that is how we change themes on the fly.

To define more themes, simply add more classes to the `themes.css` file and change the class on the `html` element.

Example:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="theme" label="themes.css" default>

```css title="themes.css"
... {
    /* other themes... */
}

.theme-2 {
    /* Primary */
    --primary-color: 62 78 111;
    --on-primary-color: 222 222 222;
    --primary-light-color: 124 124 255;
    --primary-dark-color: 12 13 80;

    /* Secondary */
    --secondary-color: 152 170 32;
    --on-secondary-color: 12 12 12;

    /* and so on... */
}

... {
    /* other themes... */
}
```

</TabItem>
<TabItem value="html" label="app.html">

```html title="app.html"
<html lang="en" class="theme-2 bg-background"></html>
```

</TabItem>
</Tabs>

## Pulling data with GraphQL

Our framework uses [GraphQL](https://graphql.org/) to pull data from the server, and `GraphQL Subscriptions` to receive
updates.

### Making a GraphQL query

In your `index.svelte` or more likely, your `+page.ts` or `+page.server.ts` file (please read up on
[routing in Svelte Kit](https://kit.svelte.dev/docs/routing#page-page-server-js)), you can make a GraphQL query using
the `gql` tag. The `graphql-tag` package provides this ability to convert the JavaScript template literal into a GraphQL
AST, which is then used by `graphql-codegen` to generate types for us to safely use.

Example usage:

```tsx
gql`
    query WidgetConfig {
        configuration_widget {
            config
            name
            type
            uuid
        }
    }
`;
```

We store our GraphQL client (urql) in a Svelte Store, which you can get, and use to make queries via urql's API.

:::warning

To effectly understand the next section, you need a basic understanding of Svelte, Svelte Kit, Graph QL, and urql:

-   [Svelte & Svelte Kit](../technologies/1.svelte_sveltekit.md)
-   [Graph QL](../technologies/11.graphql.md)
-   [urql](../technologies/9.urql.md)

:::

Here is an example Svelte [_page_](https://kit.svelte.dev/docs/routing#page-page-js) with a `Svelte Kit`
load function that makes a GraphQL query and passes the result as props to the page component:

The `WidgetConfigQuery` type and `WidgetConfigDocument` exports are generated using `graphql-codegen`, which will be
elaborated on in the next section.

```ts title="+page.ts"
import { gqlClient } from '$lib/stores/Clients';
import { get } from 'svelte/store';
import { type WidgetConfigQuery, WidgetConfigDocument } from './index.generated';

gql`
    query WidgetConfig {
        configuration_widget {
            config
            name
            type
            uuid
        }
    }
`;

export async function load({}) {
    const client = get(gqlClient);
    const response = await client.query<WidgetConfigQuery>(WidgetConfigDocument).toPromise();

    return {
        props: {
            configuration_widget: response.data?.configuration_widget,
        },
    };
}
```

```tsx title="+page.svelte"
<script lang="ts">... export let configuration_widget = {}; ...</script>
```

### Query Types & GraphQL Codegen

We use `graphql-codegen` to generate the query shape/types from the the `schema.graphql` file. You can get the schema
file by using the introspection API from the GraphQL endpoint you are calling.

In `ar2-web`, we have an npm script called `getschema` which runs `gq` to get the `schema.graphql` file and places It
in the root directory. Learn how to use `gq` to pull the schema here:
https://hasura.io/docs/latest/guides/export-graphql-schema/

```bash
npm run getschema
```

We then have another npm script called `generate` which runs graphql-codegen. It reads the `codegen.yml` configuration
file to determine how where to get `schema.graphql` (we place it in the root folder), along with all other files that
store your queries and uses these files to generate the types. They appear in a folder called `generated`
which is excluded from .git.

```bash
npm run generate
```

After generating these types, you can now have full typescript definitions for your GraphQL queries. Remember to run
`npm run getschema` again whenever your GraphQL schema changes, and to run `npm run generate` whenever you write new
queries, or need to update the queries with the new schema.

// TODO create Screen2Gif example

## Handling Authentication

// TODO - `jwt`, auth store, etc

## Managing State

// TODO Svelte Stores

A key point to take note about using Svelte Stores with Svlete Kit is that whenever stores are run on the server, it is
global - meaning when running hybrid rendering or server-side rendering (any code in `.svelte` that has no
`if (browser)` checks or isn't run inside `onMount()`). This means you should always set stores in a browser context
only.

Reference issue: https://github.com/sveltejs/kit/discussions/4339

## Testing

Successful development involves testing. It is a big topic on its own, so please visit the [testing](testing) page to
learn how we handle testing.

We are expected to write out own unit tests and participate in integration tests.

## Creating Endpoints

// TODO - src/routes/api

### Standard endpoint message format

@lamweili @tfengyun
//TBD

```tsx
{
    data: {...}, // arbitrary format - always array? GraphQL does array or obj
    message: "...", // string
    sent_at: "", //iso8601
    errors: [ {
        message: "....", // string
        ...
    } ]
}
```
